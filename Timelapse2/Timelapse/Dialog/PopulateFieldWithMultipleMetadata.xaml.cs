using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Data;
using Timelapse.Controls;
using Timelapse.Database;
using Timelapse.ExifTool;
using Timelapse.Util;

namespace Timelapse.Dialog
{
    /// <summary>
    /// Interaction logic for PopulateFieldWithMultipleMetadata.xaml
    /// </summary>
    public partial class PopulateFieldWithMultipleMetadata : BusyableDialogWindow, IDisposable
    {
        #region Private Variables
        private readonly FileDatabase fileDatabase;
        private readonly string filePath;
        private ExifToolWrapper exifTool;

        // Collects the various metadata attributes from the file. The Key is the complete metadata name 
        private Dictionary<string, ImageMetadata> metadataDictionary;

        // Track the checkbox for clearing values if no matching metadata is found
        private bool clearIfNoMetadata;

        // These are used to get the labels and data labels. 
        private readonly Dictionary<string, string> lookupNoteDataLabelByLabel;
        public ObservableCollection<string> NoteLabels { get; set; } = new ObservableCollection<string>() { "" };

        public ObservableCollection<DataContents> metadataList { get; set; } = new ObservableCollection<DataContents>();

        // Tracks whether any changes to the data or database are made
        private bool IsAnyDataUpdated;
        #endregion

        #region Constructor, Loaded, Unloaded, Autogenerate
        public PopulateFieldWithMultipleMetadata(Window owner, FileDatabase fileDatabase, string filePath) : base(owner)
        {
            ThrowIf.IsNullArgument(fileDatabase, nameof(fileDatabase));
            DataContext = this;
            this.InitializeComponent();

            this.fileDatabase = fileDatabase;
            this.filePath = filePath;

            // Store various states as set by the user
            this.clearIfNoMetadata = false;
            this.lookupNoteDataLabelByLabel = new Dictionary<string, string>();
        }

        // After the interface is loaded, 
        // - Load the metadata into the data grid
        // - Load the names of the note controls into the listbox
        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            // Set up a progress handler that will update the progress bar
            this.InitalizeProgressHandler(this.BusyCancelIndicator);

            // Set up the initial UI and values
            this.lblImageName.Content = Path.GetFileName(this.filePath);
            this.lblImageName.ToolTip = this.lblImageName.Content;

            // Construct a dictionary of the available note fields as labels:datalabels
            // and a list of only the note field labels which will be used to populate the ComboBoxes in the datagrid
            foreach (ControlRow control in this.fileDatabase.Controls)
            {
                if (control.Type == Constant.Control.Note)
                {
                    // Older templates allowed duplicate labels, which would break the dictionary as it would then have a duplicate key.
                    // So we just skip those. This should be a rare to non-existent condition, but its
                    // better than having Timelapse crash.
                    if (false == this.lookupNoteDataLabelByLabel.ContainsKey(control.Label))
                    {  
                        this.lookupNoteDataLabelByLabel.Add(control.Label, control.DataLabel);
                        this.NoteLabels.Add(control.Label);
                    }
                }
            }

            // Show the metadata of the current image, depending on the kind of tool selected
            this.MetadataToolType_Checked(null, null);

            // Add callbacks to the radio buttons. We do it here so they are not invoked when the window is loaded.
            this.MetadataExtractorRB.Checked += this.MetadataToolType_Checked;
            this.ExifToolRB.Checked += this.MetadataToolType_Checked;

            // Set the tooltip to the cell's contents
            Style CellStyle_ToolTip = new Style();
            var CellSetter = new Setter(DataGridCell.ToolTipProperty, new Binding() { RelativeSource = new RelativeSource(RelativeSourceMode.Self), Path = new PropertyPath("Content.Text") });
            CellStyle_ToolTip.Setters.Add(CellSetter);
            this.AvailableMetadataDataGrid.CellStyle = CellStyle_ToolTip;
        }

        // This datagrid will indicate, for the selected metadata, the metadata values assigned to the selected field
        private void FeedbackDatagrid_AutoGeneratedColumns(object sender, EventArgs e)
        {
            this.FeedbackGrid.Columns[0].Header = "File Name";
            this.FeedbackGrid.Columns[1].Header = "Metadata name";
            this.FeedbackGrid.Columns[2].Header = "Metadata Value";
        }
        #endregion

        #region Closing and disposing
        private void Window_Closing(object sender, System.ComponentModel.CancelEventArgs e)
        {
            this.DialogResult = this.Token.IsCancellationRequested || this.IsAnyDataUpdated;
        }

        // To follow design pattern in  CA1001 Types that own disposable fields should be disposable
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                // dispose managed resources
                if (this.exifTool != null)
                {
                    this.exifTool.Dispose();
                }
            }
            // free native resources
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
        #endregion

        #region MetadataExtractor-specific methods
        // Retrieve and show a single image's metadata in the datagrid
        private void MetadataExtractorShowImageMetadata()
        {
            // Clear the data structures so we get fresh contents
            this.metadataList.Clear();
            // Get the metadata
            this.metadataDictionary = ImageMetadataDictionary.LoadMetadata(this.filePath);


            // If there is no metadata, this is an easy way to inform the user
            if (this.metadataDictionary.Count == 0)
            {
                this.metadataDictionary.Add("Empty", new Timelapse.Util.ImageMetadata("Empty", "No metadata found in the currently displayed image", "Navigate to a displayable image"));
            }


            // In order to populate the datagrid, we have to unpack the dictionary as a list containing four values, plus a fifth item that represents the empty datalabel as ComboBox
            foreach (KeyValuePair<string, ImageMetadata> metadata in this.metadataDictionary)
            {
                metadataList.Add(new DataContents(metadata.Key, metadata.Value.Directory, metadata.Value.Name, metadata.Value.Value, String.Empty));
            }
            this.AvailableMetadataDataGrid.SortByColumnAscending(2);
        }
        #endregion

        #region ExifTool-specific methods
        private void ExifToolShowImageMetadata()
        {
            // Clear the data structures so we get fresh contents
            this.metadataDictionary.Clear();
            this.metadataList.Clear();

            // Start the exifTool process if its not already started
            if (this.exifTool == null)
            {
                this.exifTool = new ExifToolWrapper();
                this.exifTool.Start();
            }

            // Fetch the exif data using ExifTool
            Dictionary<string, string> exifDictionary = this.exifTool.FetchExifFrom(this.filePath);

            // If there is no metadata, inform the user by setting bogus dictionary values which will appear on the grid
            if (exifDictionary.Count == 0)
            {
                this.metadataDictionary.Add("Empty", new Timelapse.Util.ImageMetadata("Empty", "No metadata found in the currently displayed image", "Navigate to a displayable image"));
            }

            // In order to populate the metadataDictionary and datagrid , we have to unpack the ExifTool dictionary, recreate the dictionary, and create a list containing four values
            foreach (KeyValuePair<string, string> metadata in exifDictionary)
            {
                metadataList.Add(new DataContents(metadata.Key, String.Empty, metadata.Key, metadata.Value, ""));
            }
        }
        #endregion

        #region Do the work: Populate the database 
        // Populate the database with the metadata for the selected note field
        private async Task<ObservableCollection<Tuple<string, string, string>>> PopulateAsync(bool? metadataExtractorRBIsChecked)
        {
            // This list will hold key / value pairs that will be bound to the datagrid feedback, 
            // which is the way to make those pairs appear in the data grid during background worker progress updates
            ObservableCollection<Tuple<string, string, string>> feedbackData = new ObservableCollection<Tuple<string, string, string>>();

            // Get the Metadata / Label pairs i.e., the rows with selected labels
            Dictionary<string, string> selectedMetadataLabelPairs = GetSelectedFromMetadataList(this.metadataList);

            // if there are no metadata / label pairs, =we are done.
            if (selectedMetadataLabelPairs.Count == 0)
            {
                // Catch the case where there are no selected pairs, at least for now.
                feedbackData.Clear();
                feedbackData.Add(new Tuple<string, string, string>("Nothing was selected", "", "No changes were made"));
                return feedbackData;
            }

            // We need to get the metadata/datalabel pairs (nstead of the metadata/label pairs) as we use those to do the actual work
            Dictionary<string, string> metadataDataLabelPairs = new Dictionary<string, string>();
            foreach (KeyValuePair<string, string> kvp in selectedMetadataLabelPairs)
            {
                metadataDataLabelPairs.Add(kvp.Key, this.lookupNoteDataLabelByLabel[kvp.Value]);
            }

            return await Task.Run(() =>
            {
                // For each row in the database, get the image filename and try to extract the chosen metadata value.
                // If we can't decide if we want to leave the data field alone or to clear it depending on the state of the isClearIfNoMetadata (set via the checkbox)
                // Report progress as needed.

                // This tuple list will hold the id, key and value that we will want to update in the database
                List<ColumnTuplesWithWhere> imagesToUpdate = new List<ColumnTuplesWithWhere>();
                TimeZoneInfo imageSetTimeZone = this.fileDatabase.ImageSet.GetSystemTimeZone();
                int percentDone = 0;

                double totalImages = this.fileDatabase.CountAllCurrentlySelectedFiles;
                Dictionary<string, ImageMetadata> metadata = new Dictionary<string, ImageMetadata>();
                for (int imageIndex = 0; imageIndex < totalImages; ++imageIndex)
                {
                    // Provide feedback if the operation was cancelled during the database update
                    if (Token.IsCancellationRequested == true)
                    {
                        feedbackData.Clear();
                        feedbackData.Add(new Tuple<string, string, string>("Cancelled", "", "No changes were made"));
                        return feedbackData;
                    }

                    ImageRow image = this.fileDatabase.FileTable[imageIndex];
                    string[] tags = selectedMetadataLabelPairs.Keys.ToArray();
                    if (metadataExtractorRBIsChecked == true)
                    {   // MetadataExtractor specific code
                        metadata = ImageMetadataDictionary.LoadMetadata(image.GetFilePath(this.fileDatabase.FolderPath));
                    }
                    else
                    {
                        // ExifTool specific code - note that we transform results into the same dictionary structure used by the MetadataExtractor
                        metadata.Clear();
                        Dictionary<string, string> exifData = this.exifTool.FetchExifFrom(image.GetFilePath(this.fileDatabase.FolderPath), tags);
                        foreach (string tag in tags)
                        {
                            if (exifData.ContainsKey(tag))
                            {
                                metadata.Add(tag, new Timelapse.Util.ImageMetadata(String.Empty, tag, exifData[tag]));
                            }
                        }
                    }

                    if (this.ReadyToRefresh())
                    {
                        percentDone = Convert.ToInt32(imageIndex / totalImages * 100.0);
                        this.Progress.Report(new ProgressBarArguments(percentDone, String.Format("{0}/{1} images. Processing {2}", imageIndex, totalImages, image.File), true, false));
                        Thread.Sleep(Constant.ThrottleValues.RenderingBackoffTime);  // Allows the UI thread to update every now and then
                    }

                    string dataLabelToUpdate = "";

                    foreach (KeyValuePair<string, string> kvp in metadataDataLabelPairs)
                    {
                        string metadataTag = kvp.Key;
                        string abbreviatedMetadataTag = metadataTag.Substring(metadataTag.LastIndexOf(".") + 1);
                        dataLabelToUpdate = kvp.Value;
                        bool containsKey = false;

                        // For some reason, metadata.ContainKey wasn't working, so I am doing it manually
                        foreach (string key in metadata.Keys)
                        {
                            if (key == metadataTag)
                            {
                                containsKey = true;
                                break;
                            }
                        }

                        if (containsKey == false)
                        {
                            // This just skips this metadata as it was not found in the file's metadata
                            if (this.clearIfNoMetadata)
                            {
                                List<ColumnTuple> clearField = new List<ColumnTuple>() { new ColumnTuple(dataLabelToUpdate, String.Empty) };
                                imagesToUpdate.Add(new ColumnTuplesWithWhere(clearField, image.ID));
                                feedbackData.Add(new Tuple<string, string, string>(image.File, abbreviatedMetadataTag, "No metadata found - data field is cleared"));
                            }
                            else
                            {
                                feedbackData.Add(new Tuple<string, string, string>(image.File, abbreviatedMetadataTag, "No metadata found - data field remains unaltered"));
                            }
                            continue;
                        }


                        string metadataValue = metadata[metadataTag].Value;
                        ColumnTuplesWithWhere imageUpdate;
                        imageUpdate = new ColumnTuplesWithWhere(new List<ColumnTuple>() { new ColumnTuple(dataLabelToUpdate, metadataValue) }, image.ID);
                        feedbackData.Add(new Tuple<string, string, string>(image.File, abbreviatedMetadataTag, metadataValue));
                        imagesToUpdate.Add(imageUpdate);
                    }
                }
                this.IsAnyDataUpdated = true;
                this.Progress.Report(new ProgressBarArguments(100, String.Format("Writing metadata for {0} files. Please wait...", totalImages), false, true));
                Thread.Sleep(Constant.ThrottleValues.RenderingBackoffTime);  // Allows the UI thread to update every now and then
                this.fileDatabase.UpdateFiles(imagesToUpdate);
                return feedbackData;
            }, this.Token).ConfigureAwait(true);
        }
        #endregion

        #region Checkbox callbacks
        // Checkbox callback sets which metadata tool should be used
        private void MetadataToolType_Checked(object sender, RoutedEventArgs e)
        {
            if (this.MetadataExtractorRB.IsChecked == true)
            {
                this.MetadataExtractorShowImageMetadata();
            }
            else
            {
                this.ExifToolShowImageMetadata();
            }
        }

        // Checkbox callback sets the state as to whether the data field should be cleared or left alone if there is no metadata
        private void ClearIfNoMetadata_Checked(object sender, RoutedEventArgs e)
        {
            this.clearIfNoMetadata = (this.ClearIfNoMetadata.IsChecked == true);
        }
        #endregion

        #region Combobox (in DataGrid) callbacks
        private void ComboBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            // We need to clear any other combobox fields whose selected value matches this one, 
            // in case the user has selected a data field that was already assigned to a different metadata field.
            if (sender is ComboBox cb)
            {
                DataGridClearComboBoxesWithMatchingSelectedItem(this.AvailableMetadataDataGrid, cb, "Data label");
            }

            // Enable or disable the Start/Done (Populate) button depending on whether any data field is currently assigned.
            this.StartDoneButton.IsEnabled = false;
            foreach (DataContents dc in this.metadataList)
            {
                if (false == String.IsNullOrEmpty(dc.AssignedDataLabel))
                {
                    this.StartDoneButton.IsEnabled = true;
                    return;
                }
            }
        }
        #endregion

        #region Button callbacks
        private async void Start_Click(object sender, RoutedEventArgs e)
        {
            bool? metadataExtractorRBIsChecked = this.MetadataExtractorRB.IsChecked;

            // Update the UI to show the feedback datagrid, 
            this.PopulatingMessage.Text = "Populating metadata";
            this.CancelButton.IsEnabled = false;
            this.CancelButton.Visibility = Visibility.Hidden;
            this.StartDoneButton.Content = "_Done";
            this.StartDoneButton.Click -= this.Start_Click;
            this.StartDoneButton.Click += this.Done_Click;
            this.StartDoneButton.IsEnabled = false;
            this.BusyCancelIndicator.IsBusy = true;
            this.WindowCloseButtonIsEnabled(false);

            this.ClearIfNoMetadata.Visibility = Visibility.Collapsed; // Hide the checkbox button for the same reason
            this.PrimaryPanel.Visibility = Visibility.Collapsed;  // Hide the various panels to reveal the feedback datagrid
            this.FeedbackPanel.Visibility = Visibility.Visible;
            this.PanelHeader.Visibility = Visibility.Collapsed;
            this.ToolSelectionPanel.Visibility = Visibility.Collapsed;
            this.WindowCloseButtonIsEnabled(false);

            // This call does all the actual populating...
            ObservableCollection<Tuple<string, string, string>> feedbackData = await this.PopulateAsync(metadataExtractorRBIsChecked).ConfigureAwait(true);

            // Update the UI to its final state
            this.FeedbackGrid.ItemsSource = feedbackData;
            this.StartDoneButton.IsEnabled = true;
            this.BusyCancelIndicator.IsBusy = false;
            this.WindowCloseButtonIsEnabled(true);

            this.FeedbackGrid.ItemsSource = feedbackData;

            if (this.Token.IsCancellationRequested)
            {
                this.PopulatingMessage.Text = "Cancelled - content is unchanged.";
            }
            else
            {
                this.PopulatingMessage.Text = "Populated metadata as follows.";
            }
            if (this.exifTool != null)
            {
                    this.exifTool.Stop();   
            }
        }

        private void Done_Click(object sender, RoutedEventArgs e)
        {

            // We return true if the database was altered but also if there was a cancellation, as a cancelled operation
            // may have changed the FileTable (but not database) date entries. Returning true will reset them, as a FileSelectAndShow will be done.
            // Kinda hacky as it expects a certain behaviour of the caller, but it works.
            this.DialogResult = this.Token.IsCancellationRequested || this.IsAnyDataUpdated;
        }
        private void CancelButton_Click(object sender, RoutedEventArgs e)
        {
            this.DialogResult = this.Token.IsCancellationRequested || this.IsAnyDataUpdated;
        }
        #endregion

        #region Static Helpers
        // Return a dictionary comprised only of metadata fields with a non-empty data label (which is located in AssignedDataLabel)
        private static Dictionary<string, string> GetSelectedFromMetadataList(ObservableCollection<DataContents>metadataList)
        {   
            Dictionary<string, string> dict = new Dictionary<string, string>();
            foreach (DataContents dc in metadataList)
            {
                if (false == String.IsNullOrWhiteSpace(dc.AssignedDataLabel))
                {
                    // We have a non-empty data label, so add it.
                    dict.Add(dc.MetadataKey, dc.AssignedDataLabel);
                }
            }
            return dict;
        }

        // Purpose: Clear all comboboxes with the same data label as the currently selected one.
        // This ensures that all metadata fields will be assigned (if at all) to unique data labels.
        // Check all the comboboxes in the grid againste the currently selected combobox.
        // If its value is the same as the currently selected one, clear it.
        private static void DataGridClearComboBoxesWithMatchingSelectedItem(DataGrid dg, ComboBox selectedComboBox, string dataLabelColumnHeader)
        {
            int datalabelColumnIndex = dg.Columns.IndexOf(dg.Columns.FirstOrDefault(c => (string)c.Header == dataLabelColumnHeader));

            for (int rowIndex = 0; rowIndex < dg.Items.Count; rowIndex++)
            {
                // In order for ItemContainerGenerator to work, we need to set the DataGrid in the XAML to VirtualizingStackPanel.IsVirtualizing="False"
                DataGridRow row = (DataGridRow)dg.ItemContainerGenerator.ContainerFromIndex(rowIndex);
                if (row == null)
                {
                    continue;
                }

                // Get the two grid cells
                DataGridCellsPresenter presenter = Util.VisualChildren.GetVisualChild<DataGridCellsPresenter>(row);
                DataGridCell datalabelCell = (DataGridCell)presenter.ItemContainerGenerator.ContainerFromIndex(datalabelColumnIndex);
                if (datalabelCell.Content is ContentPresenter presenter1)
                {
                    ComboBox cb = (ComboBox)System.Windows.Media.VisualTreeHelper.GetChild(presenter1, 0);
                    //System.Diagnostics.Debug.Print(cb.Text + "|" + (string)chosenComboBox.SelectedValue);
                    if (cb != selectedComboBox && cb.Text == (string)selectedComboBox.SelectedValue)
                    {
                        cb.Text = String.Empty;
                    }
                }
            }
        }
        #endregion

        #region DataContents: A class defining the data model behind each row in the AvailableMetadataDataGrid 
        public class DataContents
        {
            public string MetadataKey { get; set; } = String.Empty;
            public string MetadataKind { get; set; } = String.Empty;
            public string MetadataName { get; set; } = String.Empty;
            public string MetadataValue { get; set; } = String.Empty;
            public string AssignedDataLabel { get; set; } = String.Empty;
            public DataContents(string metadataKey, string metadataKind, string metadataName, string metadataValue, string assignedDataLabel)
            {
                this.MetadataKey = metadataKey;
                this.MetadataKind = metadataKind;
                this.MetadataName = metadataName;
                this.MetadataValue = metadataValue;
                this.AssignedDataLabel = assignedDataLabel;
            }
        }
        #endregion
    }
}

