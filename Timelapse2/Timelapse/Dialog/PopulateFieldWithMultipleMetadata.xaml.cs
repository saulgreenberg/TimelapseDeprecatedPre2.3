using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Data;
using Timelapse.Controls;
using Timelapse.Database;
using Timelapse.ExifTool;
using Timelapse.Util;

namespace Timelapse.Dialog
{
    /// <summary>
    /// Interaction logic for PopulateFieldWithMultipleMetadata.xaml
    /// </summary>
    public partial class PopulateFieldWithMultipleMetadata : BusyableDialogWindow, IDisposable
    {
        // DEFUNCT - TO REMOVE
        private bool clearIfNoMetadata;

        #region Private Variables
        private readonly FileDatabase fileDatabase;
        private readonly string filePath;
        private ExifToolWrapper exifTool;

        private Dictionary<string, ImageMetadata> metadataDictionary;
        private string metadataFieldName;

        // These are used to get the labels and data labels. 
        private readonly Dictionary<string, string> lookupNoteDataLabelByLabel;
        public ObservableCollection<string> NoteLabels { get; set; } = new ObservableCollection<string>() { "" };

        public ObservableCollection<DataContents> metadataList { get; set; } = new ObservableCollection<DataContents>();

        // Tracks whether any changes to the data or database are made
        private bool IsAnyDataUpdated;
        #endregion

        #region Constructor, Loaded, Unloaded, Autogenerate
        public PopulateFieldWithMultipleMetadata(Window owner, FileDatabase fileDatabase, string filePath) : base(owner)
        {
            ThrowIf.IsNullArgument(fileDatabase, nameof(fileDatabase));
            DataContext = this;
            this.InitializeComponent();

            this.fileDatabase = fileDatabase;
            this.filePath = filePath;

            // Store various states as set by the user
            this.clearIfNoMetadata = false;

            this.lookupNoteDataLabelByLabel = new Dictionary<string, string>();
            this.metadataFieldName = String.Empty;
        }

        // After the interface is loaded, 
        // - Load the metadata into the data grid
        // - Load the names of the note controls into the listbox
        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            // Set up a progress handler that will update the progress bar
            this.InitalizeProgressHandler(this.BusyCancelIndicator);

            // Set up the initial UI and values
            this.lblImageName.Content = Path.GetFileName(this.filePath);
            this.lblImageName.ToolTip = this.lblImageName.Content;

            // Construct a dictionary of the available note fields as labels:datalabels
            // and a list of only the note field labels which will be used to populate the ComboBoxes in the datagrid
            foreach (ControlRow control in this.fileDatabase.Controls)
            {
                if (control.Type == Constant.Control.Note)
                {
                    this.lookupNoteDataLabelByLabel.Add(control.Label, control.DataLabel);
                    this.NoteLabels.Add(control.Label);
                }
            }

            // Show the metadata of the current image, depending on the kind of tool selected
            this.MetadataToolType_Checked(null, null);

            // Add callbacks to the radio buttons. We do it here so they are not invoked when the window is loaded.
            this.MetadataExtractorRB.Checked += this.MetadataToolType_Checked;
            this.ExifToolRB.Checked += this.MetadataToolType_Checked;

            // Set the tooltip to the cell's contents
            Style CellStyle_ToolTip = new Style();
            var CellSetter = new Setter(DataGridCell.ToolTipProperty, new Binding() { RelativeSource = new RelativeSource(RelativeSourceMode.Self), Path = new PropertyPath("Content.Text") });
            CellStyle_ToolTip.Setters.Add(CellSetter);
            this.AvailableMetadataDataGrid.CellStyle = CellStyle_ToolTip;
        }
        // This datagrid will indicate, for the selected metadata, the metadata values assigned to the selected field
        private void FeedbackDatagrid_AutoGeneratedColumns(object sender, EventArgs e)
        {
            this.FeedbackGrid.Columns[0].Header = "File Name";
            this.FeedbackGrid.Columns[1].Header = "The Metadata Value for " + this.metadataFieldName;
        }
        #endregion

        #region Closing and disposing
        private void Window_Closing(object sender, System.ComponentModel.CancelEventArgs e)
        {
            this.DialogResult = this.Token.IsCancellationRequested || this.IsAnyDataUpdated;
        }

        // To follow design pattern in  CA1001 Types that own disposable fields should be disposable
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                // dispose managed resources
                if (this.exifTool != null)
                {
                    this.exifTool.Dispose();
                }
            }
            // free native resources
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
        #endregion

        #region MetadataExtractor-specific methods
        // Retrieve and show a single image's metadata in the datagrid
        private void MetadataExtractorShowImageMetadata()
        {
            // Clear the data structures so we get fresh contents
            this.metadataList.Clear();

            // Get the metadata
            this.metadataDictionary = ImageMetadataDictionary.LoadMetadata(this.filePath);


            // If there is no metadata, this is an easy way to inform the user
            if (this.metadataDictionary.Count == 0)
            {
                this.metadataDictionary.Add("Empty", new Timelapse.Util.ImageMetadata("Empty", "No metadata found in the currently displayed image", "Navigate to a displayable image"));
            }
            else
            {
            }

            // In order to populate the datagrid, we have to unpack the dictionary as a list containing four values, plus a fifth item that represents the empty datalabel as ComboBox
            foreach (KeyValuePair<string, ImageMetadata> metadata in this.metadataDictionary)
            {
                metadataList.Add(new DataContents(metadata.Key, metadata.Value.Directory, metadata.Value.Name, metadata.Value.Value, String.Empty));
            }
            this.AvailableMetadataDataGrid.SortByColumnAscending(2);
        }
        #endregion

        #region ExifTool-specific methods
        private void ExifToolShowImageMetadata()
        {
            // Clear the data structures so we get fresh contents
            this.metadataDictionary.Clear();
            this.metadataList.Clear();

            // Start the exifTool process if its not already started
            if (this.exifTool == null)
            {
                this.exifTool = new ExifToolWrapper();
                this.exifTool.Start();
            }

            // Fetch the exif data using ExifTool
            Dictionary<string, string> exifDictionary = this.exifTool.FetchExifFrom(this.filePath);

            // If there is no metadata, inform the user by setting bogus dictionary values which will appear on the grid
            if (exifDictionary.Count == 0)
            {
                this.metadataDictionary.Add("Empty", new Timelapse.Util.ImageMetadata("Empty", "No metadata found in the currently displayed image", "Navigate to a displayable image"));
            }

            // In order to populate the metadataDictionary and datagrid , we have to unpack the ExifTool dictionary, recreate the dictionary, and create a list containing four values
            foreach (KeyValuePair<string, string> metadata in exifDictionary)
            {
                metadataList.Add(new DataContents(metadata.Key, String.Empty, metadata.Key, metadata.Value, ""));
            }
        }
        #endregion

        #region Do the work: Populate the database 
        // Populate the database with the metadata for the selected note field
        private async Task<ObservableCollection<KeyValuePair<string, string>>> PopulateAsync(bool? metadataExtractorRBIsChecked)
        {
            // This list will hold key / value pairs that will be bound to the datagrid feedback, 
            // which is the way to make those pairs appear in the data grid during background worker progress updates
            ObservableCollection<KeyValuePair<string, string>> keyValueList = new ObservableCollection<KeyValuePair<string, string>>();

            // Get the Metadata / Label pairs i.e., the rows with selected labels
            //Dictionary<string, string> selectedMetadataLabelPairs = DataGridGetSelectedMetadataLabelPairs(this.AvailableMetadataDataGrid, "Metadata name", "Data label");
            Dictionary<string, string> selectedMetadataLabelPairs = DataGridGetSelectedMetadataLabelPairs(this.AvailableMetadataDataGrid, "Key", "Data label");

            // if there are no metadata / label pairs, =we are done.
            if (selectedMetadataLabelPairs.Count == 0)
            {
                // Catch the case where there are no selected pairs, at least for now.
                keyValueList.Clear();
                keyValueList.Add(new KeyValuePair<string, string>("Nothing was selected", "No changes were made"));
                return keyValueList;
            }

            // We need to get the metadata/datalabel pairs (nstead of the metadata/label pairs) as we use those to do the actual work
            Dictionary<string, string> metadataDataLabelPairs = new Dictionary<string, string>();
            foreach (KeyValuePair<string, string> kvp in selectedMetadataLabelPairs)
            {
                metadataDataLabelPairs.Add(kvp.Key, this.lookupNoteDataLabelByLabel[kvp.Value]);
            }

            return await Task.Run(() =>
            {
                // For each row in the database, get the image filename and try to extract the chosen metadata value.
                // If we can't decide if we want to leave the data field alone or to clear it depending on the state of the isClearIfNoMetadata (set via the checkbox)
                // Report progress as needed.

                // This tuple list will hold the id, key and value that we will want to update in the database
                List<ColumnTuplesWithWhere> imagesToUpdate = new List<ColumnTuplesWithWhere>();
                TimeZoneInfo imageSetTimeZone = this.fileDatabase.ImageSet.GetSystemTimeZone();
                int percentDone = 0;

                double totalImages = this.fileDatabase.CountAllCurrentlySelectedFiles;
                Dictionary<string, ImageMetadata> metadata = new Dictionary<string, ImageMetadata>();
                for (int imageIndex = 0; imageIndex < totalImages; ++imageIndex)
                {
                    // Provide feedback if the operation was cancelled during the database update
                    if (Token.IsCancellationRequested == true)
                    {
                        keyValueList.Clear();
                        keyValueList.Add(new KeyValuePair<string, string>("Cancelled", "No changes were made"));
                        return keyValueList;
                    }

                    ImageRow image = this.fileDatabase.FileTable[imageIndex];
                    string[] tags = selectedMetadataLabelPairs.Keys.ToArray();
                    if (metadataExtractorRBIsChecked == true)
                    {   // MetadataExtractor specific code
                        metadata = ImageMetadataDictionary.LoadMetadata(image.GetFilePath(this.fileDatabase.FolderPath));
                    }
                    else
                    {
                        // ExifTool specific code - note that we transform results into the same dictionary structure used by the MetadataExtractor

                        //string[] tags = metadataDataLabelPairs.Keys.ToArray();
                        metadata.Clear();
                        Dictionary<string, string> exifData = this.exifTool.FetchExifFrom(image.GetFilePath(this.fileDatabase.FolderPath), tags);
                        foreach (string tag in tags)
                        {
                            if (exifData.ContainsKey(tag))
                            {
                                metadata.Add(tag, new Timelapse.Util.ImageMetadata(String.Empty, tag, exifData[tag]));
                            }
                        }
                    }

                    if (this.ReadyToRefresh())
                    {
                        percentDone = Convert.ToInt32(imageIndex / totalImages * 100.0);
                        this.Progress.Report(new ProgressBarArguments(percentDone, String.Format("{0}/{1} images. Processing {2}", imageIndex, totalImages, image.File), true, false));
                        Thread.Sleep(Constant.ThrottleValues.RenderingBackoffTime);  // Allows the UI thread to update every now and then
                    }

                    string dataLabelToUpdate = "";

                    foreach (KeyValuePair<string, string> kvp in metadataDataLabelPairs)
                    {
                        string metadataTag = kvp.Key;
                        dataLabelToUpdate = kvp.Value;
                        bool containsKey = false;
                        //For some reason, metadata.ContainKey wasn't working, so I am doing it manually
                        foreach (string key in metadata.Keys)
                        {
                            if (key == metadataTag)
                            {
                                containsKey = true;
                                break;
                            }
                        }
                        if (containsKey == false)
                        {
                            // This just skips this metadata as it was not found in the file's metadata
                            if (this.clearIfNoMetadata)
                            {
                                // Clear the data field if there is no metadata...
                                if (dataLabelToUpdate == Constant.DatabaseColumn.DateTime)
                                {
                                    image.SetDateTimeOffsetFromFileInfo(this.fileDatabase.FolderPath);
                                    imagesToUpdate.Add(image.GetDateTimeColumnTuples());
                                    keyValueList.Add(new KeyValuePair<string, string>(image.File, "No metadata found - date/time reread from file"));
                                }
                                else
                                {
                                    List<ColumnTuple> clearField = new List<ColumnTuple>() { new ColumnTuple(dataLabelToUpdate, String.Empty) };
                                    imagesToUpdate.Add(new ColumnTuplesWithWhere(clearField, image.ID));
                                    keyValueList.Add(new KeyValuePair<string, string>(image.File, "No metadata found - data field is cleared"));
                                }
                            }
                            else
                            {
                                keyValueList.Add(new KeyValuePair<string, string>(image.File, "No metadata found - data field remains unaltered"));
                            }
                            continue;
                        }


                        string metadataValue = metadata[metadataTag].Value;
                        ColumnTuplesWithWhere imageUpdate;
                        if (dataLabelToUpdate == Constant.DatabaseColumn.DateTime)
                        {
                            if (DateTimeHandler.TryParseMetadataDateTaken(metadataValue, imageSetTimeZone, out DateTimeOffset metadataDateTime))
                            {
                                image.SetDateTimeOffset(metadataDateTime);
                                imageUpdate = image.GetDateTimeColumnTuples();
                                keyValueList.Add(new KeyValuePair<string, string>(image.File, metadataValue));
                            }
                            else
                            {
                                keyValueList.Add(new KeyValuePair<string, string>(image.File, String.Format("'{0}' - data field remains unaltered - not a valid date/time.", metadataValue)));
                                continue;
                            }
                        }
                        else
                        {
                            imageUpdate = new ColumnTuplesWithWhere(new List<ColumnTuple>() { new ColumnTuple(dataLabelToUpdate, metadataValue) }, image.ID);
                            keyValueList.Add(new KeyValuePair<string, string>(image.File, metadataValue));
                        }
                        imagesToUpdate.Add(imageUpdate);
                    }
                }
                this.IsAnyDataUpdated = true;
                this.Progress.Report(new ProgressBarArguments(100, String.Format("Writing metadata for {0} files. Please wait...", totalImages), false, true));
                Thread.Sleep(Constant.ThrottleValues.RenderingBackoffTime);  // Allows the UI thread to update every now and then
                this.fileDatabase.UpdateFiles(imagesToUpdate);
                return keyValueList;
            }, this.Token).ConfigureAwait(true);
        }
        #endregion

        #region Callbacks to select and assign metadata fields
        // Datagrid Callack where the user has selected a row. Get the metadata from that row, and make it the selected metadata.
        // Also enable/disable UI controls as needed
        //private void Datagrid_SelectedCellsChanged(object sender, SelectedCellsChangedEventArgs e)
        //{

        //    // If there's no metadata, then just bail
        //    if (this.noMetadataAvailable == true)
        //    {
        //        return;
        //    }
        //    IList<DataGridCellInfo> selectedcells = e.AddedCells;

        //    // Make sure there are actually some selected cells
        //    if (selectedcells == null || selectedcells.Count == 0)
        //    {
        //        return;
        //    }


        //    // We should only have a single selected cell, so just grab the first one
        //    DataGridCellInfo di = selectedcells[0];

        //    // the selected item is the entire row, where the format returned is [MetadataName , MetadataValue] 
        //    // Parse out the metadata name
        //    String[] s = di.Item.ToString().Split(',');  // Get the "[Metadataname" portion before the ','
        //    this.metadataFieldName = s[0].Substring(1);              // Remove the leading '['
        //    if (this.metadataDictionary.ContainsKey(this.metadataFieldName))
        //    {
        //        //this.MetadataDisplayText.Content = this.metadataDictionary[this.metadataFieldName].Name;
        //        // Note that metadata name may still has spaces in it. We will have to strip it out and check it to make sure its an acceptable data label
        //        this.metadataFieldSelected = true;
        //        this.StartDoneButton.IsEnabled = this.dataFieldSelected && this.metadataFieldSelected;
        //    }
        //    else
        //    {
        //        //this.MetadataDisplayText.Content = String.Empty;
        //        // Note that metadata name may still has spaces in it. We will have to strip it out and check it to make sure its an acceptable data label
        //        this.metadataFieldSelected = false;
        //        this.StartDoneButton.IsEnabled = this.dataFieldSelected && this.metadataFieldSelected;
        //    }
        //}
        #endregion

        #region Checkbox callbacks
        // Checkbox callback sets which metadata tool should be used
        private void MetadataToolType_Checked(object sender, RoutedEventArgs e)
        {
            if (this.MetadataExtractorRB.IsChecked == true)
            {
                this.MetadataExtractorShowImageMetadata();
            }
            else
            {
                this.ExifToolShowImageMetadata();
            }
        }

        // Checkbox callback sets the state as to whether the data field should be cleared or left alone if there is no metadata
        private void ClearIfNoMetadata_Checked(object sender, RoutedEventArgs e)
        {
            this.clearIfNoMetadata = (this.ClearIfNoMetadata.IsChecked == true);
        }
        #endregion

        #region Button callbacks
        private async void Start_Click(object sender, RoutedEventArgs e)
        {
            foreach (DataContents foo in this.metadataList)
            {
                if (foo.Item5 != String.Empty)
                {
                    System.Diagnostics.Debug.Print("metadataList:" + foo.Item1 + "|" + foo.Item5);
                }
            }

            bool? metadataExtractorRBIsChecked = this.MetadataExtractorRB.IsChecked;

            // Update the UI to show the feedback datagrid, 
            this.PopulatingMessage.Text = "Populating metadata";
            this.CancelButton.IsEnabled = false;
            this.CancelButton.Visibility = Visibility.Hidden;
            this.StartDoneButton.Content = "_Done";
            this.StartDoneButton.Click -= this.Start_Click;
            this.StartDoneButton.Click += this.Done_Click;
            this.StartDoneButton.IsEnabled = false;
            this.BusyCancelIndicator.IsBusy = true;
            this.WindowCloseButtonIsEnabled(false);

            this.ClearIfNoMetadata.Visibility = Visibility.Collapsed; // Hide the checkbox button for the same reason
            this.PrimaryPanel.Visibility = Visibility.Collapsed;  // Hide the various panels to reveal the feedback datagrid
            this.FeedbackPanel.Visibility = Visibility.Visible;
            this.PanelHeader.Visibility = Visibility.Collapsed;
            this.ToolSelectionPanel.Visibility = Visibility.Collapsed;
            this.WindowCloseButtonIsEnabled(false);

            // This call does all the actual populating...
            ObservableCollection<KeyValuePair<string, string>> keyValueList = await this.PopulateAsync(metadataExtractorRBIsChecked).ConfigureAwait(true);

            // Update the UI to its final state
            this.FeedbackGrid.ItemsSource = keyValueList;
            this.StartDoneButton.IsEnabled = true;
            this.BusyCancelIndicator.IsBusy = false;
            this.WindowCloseButtonIsEnabled(true);

            this.FeedbackGrid.ItemsSource = keyValueList;

            if (this.Token.IsCancellationRequested)
            {
                this.PopulatingMessage.Text = "Cancelled - content is unchanged.";
            }
            else
            {
                this.PopulatingMessage.Text = "Populated metadata as follows.";
            }
            if (this.exifTool != null)
            {
                this.exifTool.Stop();
            }
        }
        private async void ModifiedStart_Click(object sender, RoutedEventArgs e)
        {
            bool? metadataExtractorRBIsChecked = this.MetadataExtractorRB.IsChecked;

            //Dictionary<string, string> selected = DataGridGetSelectedMetadataLabelPairs(this.AvailableMetadataDataGrid, "Metadata name", "Data label");
            Dictionary<string, string> selected = DataGridGetSelectedMetadataLabelPairs(this.AvailableMetadataDataGrid, "Key", "Data label");
            foreach (KeyValuePair<string, string> kvp in selected)
            {
                System.Diagnostics.Debug.Print(kvp.Key + ":" + kvp.Value);
            }

            // Update the UI to show the feedback datagrid, 


            this.CancelButton.IsEnabled = false;
            this.CancelButton.Visibility = Visibility.Hidden;
            this.StartDoneButton.Content = "_Done";
            this.StartDoneButton.Click -= this.Start_Click;
            this.StartDoneButton.Click += this.Done_Click;
            this.StartDoneButton.IsEnabled = false;


            this.ClearIfNoMetadata.Visibility = Visibility.Collapsed; // Hide the checkbox button for the same reason
            this.PrimaryPanel.Visibility = Visibility.Collapsed;  // Hide the various panels to reveal the feedback datagrid
            this.FeedbackPanel.Visibility = Visibility.Visible;

            this.PanelHeader.Visibility = Visibility.Collapsed;
            this.ToolSelectionPanel.Visibility = Visibility.Collapsed;

            if (selected.Count == 0)
            {
                this.PopulatingMessage.Text = "No metadata was assigned to a data label. Nothing done.";
                return;
            }
            else
            {

                this.PopulatingMessage.Text = "Populating your data labels with metadata";
                this.BusyCancelIndicator.IsBusy = true;
                this.WindowCloseButtonIsEnabled(false);

                // This call does all the actual populating...
                ObservableCollection<KeyValuePair<string, string>> keyValueList = await this.PopulateAsync(metadataExtractorRBIsChecked).ConfigureAwait(true);
            }

            // Update the UI to its final state
            //this.FeedbackGrid.ItemsSource = keyValueList;
            this.StartDoneButton.IsEnabled = true;
            this.BusyCancelIndicator.IsBusy = false;
            this.WindowCloseButtonIsEnabled(true);

            //this.FeedbackGrid.ItemsSource = keyValueList;

            if (this.Token.IsCancellationRequested)
            {
                this.PopulatingMessage.Text = "Cancelled: Data Fields are unchanged";
            }
            else
            {
                this.PopulatingMessage.Text = "Populated DataFields frome each file's metadata as follows.";
            }
            if (this.exifTool != null)
            {
                this.exifTool.Stop();
            }

        }
        private void Done_Click(object sender, RoutedEventArgs e)
        {

            // We return true if the database was altered but also if there was a cancellation, as a cancelled operation
            // may have changed the FileTable (but not database) date entries. Returning true will reset them, as a FileSelectAndShow will be done.
            // Kinda hacky as it expects a certain behaviour of the caller, but it works.
            this.DialogResult = this.Token.IsCancellationRequested || this.IsAnyDataUpdated;
        }
        private void CancelButton_Click(object sender, RoutedEventArgs e)
        {
            //Dictionary<string, string> selected = DataGridGetSelectedMetadataLabelPairs(this.AvailableMetadataDataGrid, "Metadata name", "Data label");
            Dictionary<string, string> selected = DataGridGetSelectedMetadataLabelPairs(this.AvailableMetadataDataGrid, "Key", "Data label");
            foreach (KeyValuePair<string, string> kvp in selected)
            {
                System.Diagnostics.Debug.Print(kvp.Key + ":" + kvp.Value);
            }
            this.DialogResult = this.Token.IsCancellationRequested || this.IsAnyDataUpdated;
        }
        #endregion

        #region Helpers
        private static Dictionary<string, string> DataGridGetSelectedMetadataLabelPairs(DataGrid dg, string metadataColumnHeader, string dataLabelColumnHeader)
        {
            Dictionary<string, string> dict = new Dictionary<string, string>();
            //int metadataColumnIndex = dg.Columns.IndexOf(dg.Columns.FirstOrDefault(c => (string)c.Header == metadataColumnHeader));
            int metadataColumnIndex = dg.Columns.IndexOf(dg.Columns.FirstOrDefault(c => (string)c.Header == metadataColumnHeader));
            int datalabelColumnIndex = dg.Columns.IndexOf(dg.Columns.FirstOrDefault(c => (string)c.Header == dataLabelColumnHeader));

            for (int rowIndex = 0; rowIndex < dg.Items.Count; rowIndex++)
            {
                // In order for ItemContainerGenerator to work, we need to set the DataGrid in the XAML to VirtualizingStackPanel.IsVirtualizing="False"
                DataGridRow row = (DataGridRow)dg.ItemContainerGenerator.ContainerFromIndex(rowIndex);
                if (row == null)
                {
                    continue;
                }

                // Get the two grid cells
                DataGridCellsPresenter presenter = Timelapse.Util.VisualChildren.GetVisualChild<DataGridCellsPresenter>(row);
                DataGridCell metadataCell = (DataGridCell)presenter.ItemContainerGenerator.ContainerFromIndex(metadataColumnIndex);
                DataGridCell datalabelCell = (DataGridCell)presenter.ItemContainerGenerator.ContainerFromIndex(datalabelColumnIndex);
                string metadata = "";
                string datalabel = "";
                if (datalabelCell.Content is ContentPresenter)
                {
                    ComboBox cb = (ComboBox)System.Windows.Media.VisualTreeHelper.GetChild((ContentPresenter)datalabelCell.Content, 0);
                    datalabel = cb.Text;
                    if (String.IsNullOrWhiteSpace(datalabel))
                    {
                        // Skip rows where no datalabel is set
                        continue;
                    }
                }
                if (metadataCell.Content is TextBlock tbCell)
                {
                    metadata = tbCell.Text;
                }
                // GOTTA DEAL WITH THE CASE WHERE THERE IS ALREAY A LABEL that is the SAME KEY
                dict.Add(metadata, datalabel);
            }
            return dict;
        }


        #endregion

        private void ComboBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            System.Diagnostics.Debug.Print(e.AddedItems[0].ToString());
        }
    }

    // The model for each row in the DataGrid
    public class DataContents
    {
        public string Item1 { get; set; } = String.Empty;
        public string Item2 { get; set; } = String.Empty;
        public string Item3 { get; set; } = String.Empty;
        public string Item4 { get; set; } = String.Empty;
        public string Item5 { get; set; } = String.Empty;

        public DataContents(string i1, string i2, string i3, string i4, string i5)
        {
            this.Item1 = i1;
            this.Item2 = i2;
            this.Item3 = i3;
            this.Item4 = i4;
            this.Item5 = i5;
        }
    }
}
