using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using Timelapse.Controls;
using Timelapse.Database;
using Timelapse.Enums;
using Timelapse.Util;

namespace Timelapse.Dialog
{
    /// <summary>
    /// Interaction logic for TestPopulate.xaml
    /// </summary>
    public partial class PopulateFieldsWithMetadata : BusyableDialogWindow
    {
        #region Private variables
        // Passed in parameters
        private readonly string FilePath;
        private readonly FileDatabase FileDatabase;

        // Tracks whether any changes to the data or database are made
        private bool isAnyDataUpdated;

        // Track the checkbox for clearing values if no matching metadata is found
        private bool clearIfNoMetadata;
        #endregion

        #region Initialization
        public PopulateFieldsWithMetadata(Window owner, FileDatabase fileDatabase, string filePath) : base(owner)
        {
            InitializeComponent();
            this.FilePath = filePath;
            this.FileDatabase = fileDatabase;
        }

        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            // Set up a progress handler that will update the progress bar
            this.InitalizeProgressHandler(this.BusyCancelIndicator);
            this.MetadataGrid.viewModel.FilePath = this.FilePath;

            // Construct a dictionary of the available note fields as labels|datalabels
            // and a list of only the note field labels which will be used to populate the ComboBoxes in the datagrid
            Dictionary<string, string> collectLabels = new Dictionary<string, string>();
            foreach (ControlRow control in this.FileDatabase.Controls)
            {
                if (control.Type == Constant.Control.Note)
                {
                    collectLabels.Add(control.DataLabel, control.Label);
                }
            }
            // Setting DictDataLabel_Label will result in desired side effects in the MetadataGrid user control
            this.MetadataGrid.DictDataLabel_Label = collectLabels;
            this.MetadataGrid.SelectedMetadata.CollectionChanged += this.SelectedMetadata_CollectionChanged;
        }

        // This datagrid will indicate, for the selected metadata, the metadata values assigned to the selected field
        private void FeedbackDatagrid_AutoGeneratedColumns(object sender, System.EventArgs e)
        {
            this.FeedbackGrid.Columns[0].Header = "File Name";
            this.FeedbackGrid.Columns[1].Header = "Metadata name";
            this.FeedbackGrid.Columns[2].Header = "Metadata Value";
        }
        #endregion

        #region Closing
        private void Window_Closing(object sender, System.ComponentModel.CancelEventArgs e)
        {
            this.DialogResult = this.Token.IsCancellationRequested || this.isAnyDataUpdated;
        }
        #endregion

        #region Change Notifications
        private void SelectedMetadata_CollectionChanged(object sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
        {
            // Enable or disable the Populate button to match if any items are in the selectedMetadataList 
            this.StartDoneButton.IsEnabled = (this.MetadataGrid.SelectedMetadata != null && this.MetadataGrid.SelectedMetadata.Count > 0);
        }
        #endregion

        #region Button callbacks
        private async void Start_Click(object sender, RoutedEventArgs e)
        {
            // Update the UI to show the feedback datagrid, 
            this.PopulatingMessage.Text = "Populating metadata";
            this.CancelButton.IsEnabled = false;
            this.CancelButton.Visibility = Visibility.Hidden;
            this.StartDoneButton.Content = "_Done";
            this.StartDoneButton.Click -= this.Start_Click;
            this.StartDoneButton.Click += this.Done_Click;
            this.StartDoneButton.IsEnabled = false;
            this.BusyCancelIndicator.IsBusy = true;
            this.WindowCloseButtonIsEnabled(false);

            this.MetadataGrid.Visibility = Visibility.Collapsed;  // Hide the various panels to reveal the feedback datagrid
            this.ClearIfNoMetadata.Visibility = Visibility.Collapsed; // Hide the checkbox button for the same reason
            this.FeedbackPanel.Visibility = Visibility.Visible; // Show the feedback panel
            this.WindowCloseButtonIsEnabled(false); // Disable the window's close button

            // This call does all the actual populating...
            ObservableCollection<Tuple<string, string, string>> feedbackData = await this.PopulateAsync(this.MetadataGrid.MetadataToolSelected).ConfigureAwait(true);

            // Update the UI to its final state
            this.StartDoneButton.IsEnabled = true;
            this.BusyCancelIndicator.IsBusy = false;
            this.WindowCloseButtonIsEnabled(true);
            this.FeedbackGrid.ItemsSource = feedbackData;
            this.PopulatingMessage.Text = this.Token.IsCancellationRequested
                ? "Cancelled - content is unchanged."
                : "Populated metadata as follows.";
        }
        private void Done_Click(object sender, RoutedEventArgs e)
        {

            // We return true if the database was altered but also if there was a cancellation, as a cancelled operation
            // may have changed the FileTable (but not database) date entries. Returning true will reset them, as a FileSelectAndShow will be done.
            // Kinda hacky as it expects a certain behaviour of the caller, but it works.
            this.DialogResult = this.Token.IsCancellationRequested || this.isAnyDataUpdated;
        }
        private void CancelButton_Click(object sender, RoutedEventArgs e)
        {
            this.DialogResult = this.Token.IsCancellationRequested || this.isAnyDataUpdated;
        }
        #endregion

        #region Checkbox callbacks
        // Checkbox callback sets the state as to whether the data field should be cleared or left alone if there is no metadata
        private void ClearIfNoMetadata_Checked(object sender, RoutedEventArgs e)
        {
            this.clearIfNoMetadata = (this.ClearIfNoMetadata.IsChecked == true);
        }
        #endregion

        #region Do the work: Populate the database 
        // Populate the database with the metadata for the selected note field
        private async Task<ObservableCollection<Tuple<string, string, string>>> PopulateAsync(MetadataToolEnum metadataToolSelected)
        {
            // This list will hold key / value pairs that will be bound to the datagrid feedback, 
            // which is the way to make those pairs appear in the data grid during background worker progress updates
            ObservableCollection<Tuple<string, string, string>> feedbackData = new ObservableCollection<Tuple<string, string, string>>();

            // Get the Metadata / Label pairs i.e., the rows with selected labels
            //Dictionary<string, string> selectedMetadataDataLabelPairs = GetSelectedFromMetadataList(this.MetadataGrid.viewModel.metadataList);


            // if there are no metadata / label pairs, we are done.
            if (this.MetadataGrid.SelectedMetadata.Count == 0)
            {
                // Catch the case where there are no selected pairs, at least for now.
                feedbackData.Clear();
                feedbackData.Add(new Tuple<string, string, string>("Nothing was selected", "", "No changes were made"));
                return feedbackData;
            }

            return await Task.Run(() =>
            {
                // For each row in the database, get the image filename and try to extract the chosen metadata value.
                // If we can't decide if we want to leave the data field alone or to clear it depending on the state of the isClearIfNoMetadata (set via the checkbox)
                // Report progress as needed.

                // This tuple list will hold the id, key and value that we will want to update in the database
                List<ColumnTuplesWithWhere> imagesToUpdate = new List<ColumnTuplesWithWhere>();
                TimeZoneInfo imageSetTimeZone = this.FileDatabase.ImageSet.GetSystemTimeZone();
                int percentDone = 0;

                double totalImages = this.FileDatabase.CountAllCurrentlySelectedFiles;
                Dictionary<string, ImageMetadata> metadata = new Dictionary<string, ImageMetadata>();
                string[] tags = this.MetadataGrid.SelectedTags;// Only needed by ExifTool, but cheap to get
                for (int imageIndex = 0; imageIndex < totalImages; ++imageIndex)
                {
                    // Provide feedback if the operation was cancelled during the database update
                    if (Token.IsCancellationRequested == true)
                    {
                        feedbackData.Clear();
                        feedbackData.Add(new Tuple<string, string, string>("Cancelled", "", "No changes were made"));
                        return feedbackData;
                    }

                    ImageRow image = this.FileDatabase.FileTable[imageIndex];

                    if (metadataToolSelected == MetadataToolEnum.MetadataExtractor)
                    {   // MetadataExtractor specific code
                        metadata = ImageMetadataDictionary.LoadMetadata(image.GetFilePath(this.FileDatabase.FolderPath));
                    }
                    else // if metadataToolSelected == MetadataToolEnum.ExifTool
                    {
                        // ExifTool specific code - note that we transform results into the same dictionary structure used by the MetadataExtractor
                        metadata.Clear();
                        Dictionary<string, string> exifData = this.MetadataGrid.ExifTool.FetchExifFrom(image.GetFilePath(this.FileDatabase.FolderPath), tags);
                        foreach (string tag in tags)
                        {
                            if (exifData.ContainsKey(tag))
                            {
                                metadata.Add(tag, new Timelapse.Util.ImageMetadata(String.Empty, tag, exifData[tag]));
                            }
                        }
                    }

                    if (this.ReadyToRefresh())
                    {
                        percentDone = Convert.ToInt32(imageIndex / totalImages * 100.0);
                        this.Progress.Report(new ProgressBarArguments(percentDone, String.Format("{0}/{1} images. Processing {2}", imageIndex, totalImages, image.File), true, false));
                        Thread.Sleep(Constant.ThrottleValues.RenderingBackoffTime);  // Allows the UI thread to update every now and then
                    }

                    string dataLabelToUpdate = "";

                    foreach (KeyValuePair<string, string> kvp in this.MetadataGrid.SelectedMetadata)
                    {
                        string metadataTag = kvp.Key;
                        string abbreviatedMetadataTag = metadataTag.Substring(metadataTag.LastIndexOf(".") + 1);
                        dataLabelToUpdate = kvp.Value;
                        bool containsKey = false;

                        // For some reason, metadata.ContainKey wasn't working, so I am doing it manually
                        foreach (string key in metadata.Keys)
                        {
                            if (key == metadataTag)
                            {
                                containsKey = true;
                                break;
                            }
                        }

                        if (containsKey == false)
                        {
                            // This just skips this metadata as it was not found in the file's metadata
                            if (this.clearIfNoMetadata)
                            {
                                List<ColumnTuple> clearField = new List<ColumnTuple>() { new ColumnTuple(dataLabelToUpdate, String.Empty) };
                                imagesToUpdate.Add(new ColumnTuplesWithWhere(clearField, image.ID));
                                feedbackData.Add(new Tuple<string, string, string>(image.File, abbreviatedMetadataTag, "No metadata found - data field is cleared"));
                            }
                            else
                            {
                                feedbackData.Add(new Tuple<string, string, string>(image.File, abbreviatedMetadataTag, "No metadata found - data field remains unaltered"));
                            }
                            continue;
                        }
                        string metadataValue = metadata[metadataTag].Value;
                        ColumnTuplesWithWhere imageUpdate;
                        imageUpdate = new ColumnTuplesWithWhere(new List<ColumnTuple>() { new ColumnTuple(dataLabelToUpdate, metadataValue) }, image.ID);
                        feedbackData.Add(new Tuple<string, string, string>(image.File, abbreviatedMetadataTag, metadataValue));
                        imagesToUpdate.Add(imageUpdate);
                    }
                }
                this.isAnyDataUpdated = true;
                this.Progress.Report(new ProgressBarArguments(100, String.Format("Writing metadata for {0} files. Please wait...", totalImages), false, true));
                Thread.Sleep(Constant.ThrottleValues.RenderingBackoffTime);  // Allows the UI thread to update every now and then
                this.FileDatabase.UpdateFiles(imagesToUpdate);
                return feedbackData;
            }, this.Token).ConfigureAwait(true);
        }
        #endregion
    }
}
